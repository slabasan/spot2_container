<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>User Guide &mdash; SPOT 0.5.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Query Language" href="query_lang.html" />
    <link rel="prev" title="Getting Started" href="getting_started.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> SPOT
          </a>
              <div class="version">
                0.5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Docs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#data-structures-in-hatchet">Data structures in hatchet</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reading-in-a-dataset">Reading in a dataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="#visualizing-the-data">Visualizing the data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dataframe-operations">Dataframe operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#graph-operations">Graph operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#graphframe-operations">GraphFrame operations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="query_lang.html">Query Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_generation.html">Generating Profiling Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis_examples.html">Analysis Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="basic_tutorial.html">Basic Tutorial: Hatchet 101</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="developer_guide.html">Developer Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="publications.html">Publications and Presentations</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="source/hatchet.html">Hatchet API Docs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SPOT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>User Guide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/user_guide.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="user-guide">
<h1>User Guide<a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h1>
<p>Hatchet is a Python tool that simplifies the process of analyzing hierarchical
performance data such as calling context trees. Hatchet uses pandas dataframes
to store the data on each node of the hierarchy and keeps the graph
relationships between the nodes in a different data structure that is kept
consistent with the dataframe.</p>
<section id="data-structures-in-hatchet">
<h2>Data structures in hatchet<a class="headerlink" href="#data-structures-in-hatchet" title="Permalink to this headline">¶</a></h2>
<p>Hatchet’s primary data structure is a <code class="docutils literal notranslate"><span class="pre">GraphFrame</span></code>, which combines a
structured index in the form of a graph with a pandas dataframe.  The images
on the right show the two objects in a <code class="docutils literal notranslate"><span class="pre">GraphFrame</span></code> – a <code class="docutils literal notranslate"><span class="pre">Graph</span></code> object (the
index), and a <code class="docutils literal notranslate"><span class="pre">DataFrame</span> <span class="pre">object</span></code> storing the metrics associated with each
node.</p>
<a class="reference internal image-reference" href="_images/sample-graph.png"><img alt="_images/sample-graph.png" class="align-right" src="_images/sample-graph.png" style="width: 192.9px; height: 207.29999999999998px;" /></a>
<p><strong>Graphframe</strong> stores the performance data that is read in from an HPCToolkit
database, Caliper Json or Cali file, or gprof/callgrind DOT file. Typically,
the raw input data is in the form of a tree. However, since subsequent
operations on the tree can lead to new edges being created which can turn the
tree into a graph, we store the input data as a directed graph. The graphframe
consists of a graph object that stores the edge relationships between nodes and
a dataframe that stores different metrics (numerical data) and categorical data
associated with each node.</p>
<a class="reference internal image-reference" href="_images/sample-dataframe.png"><img alt="_images/sample-dataframe.png" class="align-right" src="_images/sample-dataframe.png" style="width: 218.75px; height: 194.6px;" /></a>
<p><strong>Graph</strong>: The graph can be connected or disconnected (multiple roots) and each
node in the graph can have one or more parents and children. The node stores
its frame, which can be defined by the reader. The call path is derived by
appending the frames from the root to a given node.</p>
<p><strong>Dataframe</strong>: The dataframe holds all the numerical and categorical data
associated with each node. Since typically the call tree data is per process, a
multiindex composed of the node and MPI rank is used to index into the
dataframe.</p>
</section>
<section id="reading-in-a-dataset">
<h2>Reading in a dataset<a class="headerlink" href="#reading-in-a-dataset" title="Permalink to this headline">¶</a></h2>
<p>One can use one of several static methods defined in the GraphFrame class to
read in an input dataset using hatchet. For example, if a user has an
HPCToolkit database directory that they want to analyze, they can use the
<code class="docutils literal notranslate"><span class="pre">from_hpctoolkit</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">hatchet</span> <span class="k">as</span> <span class="nn">ht</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">dirname</span> <span class="o">=</span> <span class="s2">&quot;hatchet/tests/data/hpctoolkit-cpi-database&quot;</span>
    <span class="n">gf</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">GraphFrame</span><span class="o">.</span><span class="n">from_hpctoolkit</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly if the input file is a split-JSON output by Caliper, they can use
the <code class="docutils literal notranslate"><span class="pre">from_caliper</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">hatchet</span> <span class="k">as</span> <span class="nn">ht</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;hatchet/tests/data/caliper-lulesh-json/lulesh-sample-annotation-profile.json&quot;</span><span class="p">)</span>
    <span class="n">gf</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">GraphFrame</span><span class="o">.</span><span class="n">from_caliper</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>Examples of reading in other file formats can be found in
<a class="reference internal" href="analysis_examples.html"><span class="doc">Analysis Examples</span></a>.</p>
</section>
<section id="visualizing-the-data">
<h2>Visualizing the data<a class="headerlink" href="#visualizing-the-data" title="Permalink to this headline">¶</a></h2>
<a class="reference internal image-reference" href="_images/vis-terminal.png"><img alt="_images/vis-terminal.png" class="align-right" src="_images/vis-terminal.png" style="width: 203.20000000000002px; height: 287.2px;" /></a>
<p>When the graph represented by the input dataset is small, the user may be interested in visualizing it in entirety or a portion of it. Hatchet provides several mechanisms to visualize the graph in hatchet. One can use the <code class="docutils literal notranslate"><span class="pre">tree()</span></code> function to convert the graph into a string that can be printed on standard output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">tree</span><span class="p">())</span>
</pre></div>
</div>
<p>One can also use the <code class="docutils literal notranslate"><span class="pre">to_dot()</span></code> function to output the tree as a string in the Graphviz’ DOT format. This can be written to a file and then used to display a tree using the <code class="docutils literal notranslate"><span class="pre">dot</span></code> or <code class="docutils literal notranslate"><span class="pre">neato</span></code> program.</p>
<a class="reference internal image-reference" href="_images/vis-dot.png"><img alt="_images/vis-dot.png" class="align-right" src="_images/vis-dot.png" style="width: 259.25px; height: 247.75px;" /></a>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;test.dot&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dot_file</span><span class="p">:</span>
    <span class="n">dot_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">to_dot</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>dot -Tpdf test.dot &gt; test.pdf
</pre></div>
</div>
<p>One can also use the <code class="docutils literal notranslate"><span class="pre">to_flamegraph</span></code> function to output the tree as a string
in the folded stack format required by flamegraph. This file can then be used to
create a flamegraph using <code class="docutils literal notranslate"><span class="pre">flamegraph.pl</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;test.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">folded_stack</span><span class="p">:</span>
    <span class="n">folded_stack</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">to_flamegraph</span><span class="p">())</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./flamegraph.pl test.txt &gt; test.svg
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/vis-flamegraph.png"><img alt="_images/vis-flamegraph.png" src="_images/vis-flamegraph.png" style="width: 520.0px; height: 130.5px;" /></a>
<p>One can also print the contents of the dataframe to standard output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s2">&quot;display.width&quot;</span><span class="p">,</span> <span class="mi">1200</span><span class="p">)</span>
<span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s2">&quot;display.max_colwidth&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">dataframe</span><span class="p">)</span>
</pre></div>
</div>
<p>If there are many processes or threads in the dataframe, one can also print
a cross section of the dataframe, say the values for rank 0, like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;rank&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>One can also view the graph in Hatchet’s interactive visualization for Jupyter.
In the Jupyter visualization shown below, users can explore their data by using
their mouse to select and hide nodes. For those nodes selected, a table in the
the upper right will display the metadata for the node(s) selected. The
interactive visualization capability is still in the research stage, and is
under development to improve and extend its capabilities. Currently, this
feature is available for the literal graph/tree format, which is specified as a
list of dictionaries. More on the literal format can be seen <a class="reference external" href="https://hatchet.readthedocs.io/en/latest/analysis_examples.html">here</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">roundtrip_path</span> <span class="o">=</span> <span class="s2">&quot;hatchet/external/roundtrip/&quot;</span>
<span class="o">%</span><span class="n">load_ext</span> <span class="n">roundtrip</span>
<span class="n">literal_graph</span> <span class="o">=</span> <span class="p">[</span> <span class="o">...</span> <span class="p">]</span>
<span class="o">%</span><span class="n">loadVisualization</span> <span class="n">roundtrip_path</span> <span class="n">literal_graph</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/jupyter-tree-overview.png"><img alt="_images/jupyter-tree-overview.png" class="align-center" src="_images/jupyter-tree-overview.png" style="width: 696.5px; height: 270.9px;" /></a>
<p>Once the user has explored their data, the interactive visualization outputs
the corresponding call path query of the selected nodes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">fetchData</span> <span class="n">myQuery</span>
<span class="nb">print</span><span class="p">(</span><span class="n">myQuery</span><span class="p">)</span>  <span class="c1"># displays [{&quot;name&quot;: &quot;corge&quot;}, &quot;*&quot;] for the selection above</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/jupyter-query-filter.png"><img alt="_images/jupyter-query-filter.png" class="align-right" src="_images/jupyter-query-filter.png" style="width: 204.6px; height: 134.51999999999998px;" /></a>
<p>This query can then be integrated into future workflows to automate the
filtering of the data by the desired query in a Python script. For the
selection above, we save the resulting query as a string and pass it to
Hatchet’s <code class="docutils literal notranslate"><span class="pre">filter()</span></code> function to filter the input literal graph. An example
code snippet is shown below, with the resulting filtered graph shown on the
right.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">myQuery</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;corge&quot;</span><span class="p">},</span> <span class="s2">&quot;*&quot;</span><span class="p">]</span>
<span class="n">gf</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">GraphFrame</span><span class="o">.</span><span class="n">from_literal</span><span class="p">(</span><span class="n">literal_graph</span><span class="p">)</span>
<span class="n">filter_gf</span> <span class="o">=</span> <span class="n">gf</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">myQuery</span><span class="p">)</span>
</pre></div>
</div>
<p>An example notebook of the interactive visualization can be found in the
<cite>docs/examples/tutorials</cite> directory.</p>
</section>
<section id="dataframe-operations">
<h2>Dataframe operations<a class="headerlink" href="#dataframe-operations" title="Permalink to this headline">¶</a></h2>
<a class="reference internal image-reference" href="_images/sample-dataframe.png"><img alt="_images/sample-dataframe.png" class="align-right" src="_images/sample-dataframe.png" style="width: 250.0px; height: 222.4px;" /></a>
<p><strong>filter</strong>: <code class="docutils literal notranslate"><span class="pre">filter</span></code> takes a user-supplied function or query object and
applies that to all rows in the DataFrame. The resulting Series or DataFrame is
used to filter the DataFrame to only return rows that are true. The returned
GraphFrame preserves the original graph provided as input to the filter
operation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">filtered_gf</span> <span class="o">=</span> <span class="n">gf</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">10.0</span><span class="p">)</span>
</pre></div>
</div>
<p>The images on the right show a DataFrame before and after a filter
operation.</p>
<a class="reference internal image-reference" href="_images/filter-dataframe.png"><img alt="_images/filter-dataframe.png" class="align-right" src="_images/filter-dataframe.png" style="width: 250.8px; height: 158.8px;" /></a>
<p>An alternative way to filter the DataFrame is to supply a query path in the
form of a query object. A query object is a list of <em>abstract graph nodes</em> that
specifies a call path pattern to search for in the GraphFrame. An <em>abstract
graph node</em> is made up of two parts:</p>
<ul class="simple">
<li><p>A wildcard that specifies the number of real nodes to match to the abstract
node. This is represented as either a string with value “.” (match one node),
“*” (match zero or more nodes), or “+” (match one or more nodes) or an integer
(match exactly that number of nodes). By default, the wildcard is “.” (or 1).</p></li>
<li><p>A filter that is used to determine whether a real node matches the abstract
node. In the high-level API, this is represented as a Python dictionary keyed
on column names from the DataFrame. By default, the filter is an “always true”
filter (represented as an empty dictionary).</p></li>
</ul>
<p>The query object is represented as a Python list of abstract nodes. To specify
both parts of an abstract node, use a tuple with the first element being the
wildcard and the second element being the filter.  To use a default value for
either the wildcard or the filter, simply provide the other part of the
abstract node on its own (no need for a tuple). The user <strong>must</strong> provide at
least one of the parts of the above definition of an abstract node.</p>
<a class="reference internal image-reference" href="_images/sample-graph.png"><img alt="_images/sample-graph.png" class="align-right" src="_images/sample-graph.png" style="width: 192.9px; height: 207.29999999999998px;" /></a>
<p>The query language example below looks for all paths that match first a single
node with name <cite>solvers</cite>, followed by 0 or more nodes with an inclusive time
greater than 10, followed by a single node with name that starts with <cite>p</cite> and
ends in an integer and has an inclusive time greater than or equal to 10. When
the query is used to filter and squash the the graph shown on the right, the
returned GraphFrame contains the nodes shown in the table on the right.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="_images/query-dataframe.png"><img alt="_images/query-dataframe.png" class="align-right" src="_images/query-dataframe.png" style="width: 250.95px; height: 113.74999999999999px;" /></a>
<p>Filter is one of the operations that leads to the graph object and DataFrame
object becoming inconsistent. After a filter operation, there are nodes in the
graph that do not return any rows when used to index into the DataFrame.
Typically, the user will perform a squash on the GraphFrame after a filter
operation to make the graph and DataFrame objects consistent again. This can be
done either by manually calling the <code class="docutils literal notranslate"><span class="pre">squash</span></code> function on the new GraphFrame
or by setting the <code class="docutils literal notranslate"><span class="pre">squash</span></code> parameter of the <code class="docutils literal notranslate"><span class="pre">filter</span></code> function to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">query</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;solvers&quot;</span><span class="p">},</span>
    <span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;time (inc)&quot;</span><span class="p">:</span> <span class="s2">&quot;&gt; 10&quot;</span><span class="p">}),</span>
    <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;p[a-z]+[0-9]&quot;</span><span class="p">,</span> <span class="s2">&quot;time (inc)&quot;</span><span class="p">:</span> <span class="s2">&quot;&gt;= 10&quot;</span><span class="p">}</span>
<span class="p">]</span>

<span class="n">filtered_gf</span> <span class="o">=</span> <span class="n">gf</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>drop_index_levels</strong>: When there is per-MPI process or per-thread
data in the DataFrame, a user might be interested in aggregating the data in
some fashion to analyze the graph at a coarser granularity. This function
allows the user to drop the additional index columns in the hierarchical index
by specifying an aggregation function. Essentially, this performs a
<code class="docutils literal notranslate"><span class="pre">groupby</span></code> and <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> operation on the DataFrame. The user-supplied
function is used to perform the aggregation over all MPI processes or threads
at the per-node granularity.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gf</span><span class="o">.</span><span class="n">drop_index_levels</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>update_inclusive_columns</strong>: When a graph is rewired (i.e., the
parent-child connections are modified), all the columns in the DataFrame that
store inclusive values of a metric become inaccurate. This function performs a
post-order traversal of the graph to update all columns that store inclusive
metrics in the DataFrame for each node.</p>
<a class="reference internal image-reference" href="_images/sample-graph.png"><img alt="_images/sample-graph.png" class="align-right" src="_images/sample-graph.png" style="width: 192.9px; height: 207.29999999999998px;" /></a>
</section>
<section id="graph-operations">
<h2>Graph operations<a class="headerlink" href="#graph-operations" title="Permalink to this headline">¶</a></h2>
<p><strong>traverse</strong>: A generator function that performs a pre-order traversal of the
graph and generates a sequence of all nodes in the graph in that order.</p>
<p><strong>squash</strong>: The <code class="docutils literal notranslate"><span class="pre">squash</span></code> operation is typically performed by the user after a
<code class="docutils literal notranslate"><span class="pre">filter</span></code> operation on the DataFrame.  The squash operation removes nodes from
the graph that were previously removed from the DataFrame due to a filter
operation. When one or more nodes on a path are removed from the graph, the
nearest remaining ancestor is connected by an edge to the nearest remaining
child on the path. All call paths in the graph are re-wired in this manner.</p>
<a class="reference internal image-reference" href="_images/squash-graph.png"><img alt="_images/squash-graph.png" class="align-right" src="_images/squash-graph.png" style="width: 198.0px; height: 162.29999999999998px;" /></a>
<p>A squash operation creates a new DataFrame in addition to the new graph. The
new DataFrame contains all rows from the original DataFrame, but its index
points to nodes in the new graph. Additionally, a squash operation will make
the values in all columns containing inclusive metrics inaccurate, since the
parent-child relationships have changed. Hence, the squash operation also calls
<code class="docutils literal notranslate"><span class="pre">update_inclusive_columns</span></code> to make all inclusive columns in the DataFrame
accurate again.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">filtered_gf</span> <span class="o">=</span> <span class="n">gf</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">10.0</span><span class="p">)</span>
<span class="n">squashed_gf</span> <span class="o">=</span> <span class="n">filtered_gf</span><span class="o">.</span><span class="n">squash</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>equal</strong>: The <code class="docutils literal notranslate"><span class="pre">==</span></code> operation checks whether two graphs have the same nodes
and edge connectivity when traversing from their roots.  If they are
equivalent, it returns true, otherwise it returns false.</p>
<p><strong>union</strong>: The <code class="docutils literal notranslate"><span class="pre">union</span></code> function takes two graphs and creates a unified graph,
preserving all edges structure of the original graphs, and merging nodes with
identical context.  When Hatchet performs binary operations on two GraphFrames
with unequal graphs, a union is performed beforehand to ensure that the graphs
are structurally equivalent.  This ensures that operands to element-wise
operations like add and subtract, can be aligned by their respective nodes.</p>
</section>
<section id="graphframe-operations">
<h2>GraphFrame operations<a class="headerlink" href="#graphframe-operations" title="Permalink to this headline">¶</a></h2>
<p><strong>copy</strong>: The <code class="docutils literal notranslate"><span class="pre">copy</span></code> operation returns a shallow copy of a GraphFrame.  It
creates a new GraphFrame with a copy of the original GraphFrame’s DataFrame,
but the same graph.  As mentioned earlier, graphs in Hatchet use immutable
semantics, and they are copied only when they need to be restructured.  This
property allows us to reuse graphs from GraphFrame to GraphFrame if the
operations performed on the GraphFrame do not mutate the graph.</p>
<p><strong>deepcopy</strong>: The <code class="docutils literal notranslate"><span class="pre">deepcopy</span></code> operation returns a deep copy of a GraphFrame.
It is similar to <code class="docutils literal notranslate"><span class="pre">copy</span></code>, but returns a new GraphFrame with a copy of the
original GraphFrame’s DataFrame and a copy of the original GraphFrame’s graph.</p>
<p><strong>unify</strong>: <code class="docutils literal notranslate"><span class="pre">unify</span></code> operates on GraphFrames, and calls union on the two
graphs, and then reindexes the DataFrames in both GraphFrames to be indexed by
the nodes in the unified graph.  Binary operations on GraphFrames call unify
which in turn calls union on the respective graphs.</p>
<p><strong>add</strong>: Assuming the graphs in two GraphFrames are equal, the <code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">(+)</span></code>
operation computes the element-wise sum of two DataFrames.  In the case where
the two graphs are not identical, <code class="docutils literal notranslate"><span class="pre">unify</span></code> (described above) is applied first
to create a unified graph before performing the sum.  The DataFrames are copied
and reindexed by the combined graph, and the add operation returns new
GraphFrame with the result of adding these DataFrames. Hatchet also provides an
in-place version of the add operator: <code class="docutils literal notranslate"><span class="pre">+=</span></code>.</p>
<p><strong>subtract</strong>:  The subtract operation is similar to the add operation in that
it requires the two graphs to be identical.  It applies <code class="docutils literal notranslate"><span class="pre">union</span></code> and reindexes
DataFrames if necessary.  Once the graphs are unified, the subtract operation
computes the element-wise difference between the two DataFrames.  The subtract
operation returns a new GraphFrame, or it modifies one of the GraphFrames in
place in the case of the in-place subtraction (<code class="docutils literal notranslate"><span class="pre">-=</span></code>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gf1</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">GraphFrame</span><span class="o">.</span><span class="n">from_literal</span><span class="p">(</span> <span class="o">...</span> <span class="p">)</span>
<span class="n">gf2</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">GraphFrame</span><span class="o">.</span><span class="n">from_literal</span><span class="p">(</span> <span class="o">...</span> <span class="p">)</span>
<span class="n">gf2</span> <span class="o">-=</span> <span class="n">gf1</span>
</pre></div>
</div>
<p><a class="reference internal" href="_images/diff-graph2.png"><img alt="pic1" src="_images/diff-graph2.png" style="width: 192.9px; height: 207.29999999999998px;" /></a> - <a class="reference internal" href="_images/diff-graph1.png"><img alt="pic2" src="_images/diff-graph1.png" style="width: 192.9px; height: 207.29999999999998px;" /></a> = <a class="reference internal" href="_images/diff-graph3.png"><img alt="pic3" src="_images/diff-graph3.png" style="width: 192.9px; height: 207.29999999999998px;" /></a></p>
<p><strong>tree</strong>: The <code class="docutils literal notranslate"><span class="pre">tree</span></code> operation returns the graphframe’s graph structure as a
string that can be printed to the console. By default, the tree uses the
<code class="docutils literal notranslate"><span class="pre">name</span></code> of each node and the associated <code class="docutils literal notranslate"><span class="pre">time</span></code> metric as the string
representation. This operation uses automatic color by default, but True or
False can be used to force override.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="getting_started.html" class="btn btn-neutral float-left" title="Getting Started" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="query_lang.html" class="btn btn-neutral float-right" title="Query Language" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2022, LLNS.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>